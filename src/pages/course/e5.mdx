<section>

# F√ºggv√©nyek

K√©pzeld el, hogy van egy robotod.

Meg tudod tan√≠tani, hogy v√©gezzen el egy feladatot egyszer, adj neki egy nevet, √©s onnant√≥l kezdve, amikor csak sz√ºks√©ged van r√°, el√©g csak a nev√©t 'h√≠vni', nem kell mindig √∫jra le√≠rnod.

Pontosan ezt csin√°lj√°k a f√ºggv√©nyek a Pythonban:
‚û°Ô∏è √öj ‚Äûk√©pess√©get‚Äù tan√≠tasz a Python-nak, √©s nevet adsz neki, √≠gy b√°rmikor √∫jra haszn√°lhatod.

```py
def koszont():
    print("Hell√≥, vil√°g!")

koszont()
```

Valami hasznosabb esetleg?

```py
def negyzet(x):
    return x*x
 
print(negyzet(5))
```

## F√ºggv√©nyek fel√©p√≠t√©se

```py
def fuggveny_nev(parameterek):
```

`def` &rarr; **kulcssz√≥**, ami azt jelenti: ‚ÄûMost defini√°lok egy f√ºggv√©nyt.‚Äù

`fuggveny_nev` &rarr; **a f√ºggv√©ny neve** (mint amikor elnevezed a robotodat).

`(parameterek)` &rarr; kis dobozok az inform√°ci√≥nak, **amit a f√ºggv√©ny kaphat**.

`:` &rarr; jelzi a Python-nak: ‚ÄûMost j√∂nnek az utas√≠t√°sok.‚Äù

## Return

A f√ºggv√©nyek n√©ha nem csak csin√°lnak valamit (pl. ki√≠rnak sz√∂veget), hanem vissza is adnak egy eredm√©nyt.
Ehhez haszn√°ljuk a `return` kulcssz√≥t.

```py
def osszead(a, b):
    return a + b

eredmeny = osszead(3, 5)
print(eredmeny)
```

</section>

<section>

# Lok√°lis v√°ltoz√≥k

K√©pzeld el, hogy van egy robotod, √©s annak van egy kis saj√°t fi√≥kja.
Amikor a robot dolgozik, ebbe a fi√≥kba teszi azokat a v√°ltoz√≥kat, amiket csak ≈ë ismer.
Ezeket nevezz√ºk lok√°lis v√°ltoz√≥knak.

üëâ A lok√°lis v√°ltoz√≥ csak abban a f√ºggv√©nyben √©l, ahol l√©trehoztad.
Amint a f√ºggv√©ny lefut, a v√°ltoz√≥ elt≈±nik ‚Äì mintha a robot lez√°rn√° a fi√≥kj√°t.


```py
def szorzas():
    eredmeny = 3 * 5   # lok√°lis v√°ltoz√≥
    print("Az eredm√©ny:", eredmeny)

szorzas()
print(eredmeny)  # ‚ùå hiba!
```

# Glob√°lis vs. Lok√°lis

Glob√°lis v√°ltoz√≥ &rarr; mindenki l√°tja (a teljes programban).

Lok√°lis v√°ltoz√≥ &rarr; csak a f√ºggv√©ny l√°tja, ahol l√©trej√∂tt.


</section>

<section>

# Procedur√°lis/hierarchikus programoz√°s

K√©pzeld el, hogy a programod egy sz√≠ndarab üé≠.

A f√ºggv√©nyek = a sz√≠n√©szek, akik tudnak k√ºl√∂nb√∂z≈ë dolgokat.

A main f√ºggv√©ny = a f≈ëszerepl≈ë, aki elind√≠tja a darabot, √©s megmondja, milyen sorrendben t√∂rt√©njenek a dolgok.

```py
def main():
    print("Hell√≥, √©n vagyok a f≈ëszerepl≈ë!")
    seged()

def seged():
    print("√ân pedig egy mell√©kszerepl≈ë vagyok.")

if __name__ == "__main__":
    main()
```

Mit jelentenek ezek?

if __name__ == "__main__":

Ez egy var√°zsformula ‚ú®, ami azt mondja:

‚ÄûHa k√∂zvetlen√ºl futtatod ezt a f√°jlt, ind√≠tsd el a main()-t!‚Äù

Ha viszont csak import√°lod a f√°jlt m√°shonnan, akkor nem fut el automatikusan a main().

</section>

<section>

### √çrj egy programot, amely sz√©pen form√°zva ki√≠r egy heti menzai √©tlapot!
Haszn√°lj benne speci√°lis karaktereket:

`\t`  &rarr; tabul√°tor (beh√∫z√°s)

`\n ` &rarr; √∫j sor

`\\ ` &rarr; visszaperjel megjelen√≠t√©se

### T√©glalap rajzol√°sa karakterekkel

```python
szelesseg = int(input("Add meg a t√©glalap sz√©less√©g√©t: "))
magassag = int(input("Add meg a t√©glalap magass√°g√°t: "))

# Fels≈ë szeg√©ly
print("+" + "-" * szelesseg + "+")

# K√∂z√©ps≈ë sorok
for _ in range(magassag - 2):
    print("|" + " " * szelesseg + "|")

# Als√≥ szeg√©ly, ha magass√°g legal√°bb 2
if magassag >= 2:
    print("+" + "-" * szelesseg + "+")

```

1. P√©nzv√°lt√≥ program
1. legkissebb kozos tobbszoros
1. faktorialis?
1. CMD -> python CMD notepad.exe
2. Python turtle
3. turtle feladatok - k√∂r, h√°romsz√∂g, pizza
4. A Python debugger (p√©ld√°ul pdb) egy eszk√∂z, amivel l√©p√©sr≈ël l√©p√©sre meg√°ll√≠thatod √©s √°tvizsg√°lhatod a programod fut√°s√°t.

</section>

<section>

1. A while-ra egy p√©lda esetleg lott√≥sz√°m sorsol√°s, t√∂bbsz√∂r √ºgyan az nem lehet. while $i <= 5$
2. algoritmus, telefonkonyv egyes√©vel, kettes√©vel, binaris kereses?

</section>