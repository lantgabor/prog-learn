<section>

# Ism√©tl√©s

- **Debugger**
  - L√©p√©senk√©nti futtat√°s
  - V√°ltoz√≥k figyel√©se
  - Hib√°k forr√°s√°nak felder√≠t√©se
  - Hogyan m≈±k√∂dik?
    - Breakpoint
    - V√©grehajt√°s ir√°ny√≠t√°sa
    - Mem√≥ria √©s v√°ltoz√≥k vizsg√°lata
    - Fut√°s k√∂zbeni m√≥dos√≠t√°s

- **Pszeudov√©letlen sz√°mok**
  - √Ålv√©letlensz√°m-gener√°tor
  - `random.randint()`
  - L√°va l√°mpa p√©lda

</section>

<section>

# F√ºggv√©nyek

K√©pzeld el, hogy van egy robotod.

Meg tudod tan√≠tani, hogy v√©gezzen el egy feladatot egyszer, adj neki egy nevet, √©s onnant√≥l kezdve, amikor csak sz√ºks√©ged van r√°, el√©g csak a nev√©t 'h√≠vni', nem kell mindig √∫jra le√≠rnod.

Pontosan ezt csin√°lj√°k a f√ºggv√©nyek a Pythonban:
‚û°Ô∏è √öj ‚Äûk√©pess√©get‚Äù tan√≠tasz a Python-nak, √©s nevet adsz neki, √≠gy b√°rmikor √∫jra haszn√°lhatod.

```py
def koszont():
    print("Hell√≥, vil√°g!")

koszont()
```

Valami hasznosabb esetleg?

```py
def negyzet(x):
    return x*x
 
print(negyzet(5))
```

## F√ºggv√©nyek fel√©p√≠t√©se

```py
def fuggveny_nev(parameterek):
```

`def` &rarr; **kulcssz√≥**, ami azt jelenti: ‚ÄûMost defini√°lok egy f√ºggv√©nyt.‚Äù

`fuggveny_nev` &rarr; **a f√ºggv√©ny neve** (mint amikor elnevezed a robotodat).

`(parameterek)` &rarr; kis dobozok az inform√°ci√≥nak, **amit a f√ºggv√©ny kaphat**.

`:` &rarr; jelzi a Python-nak: ‚ÄûMost j√∂nnek az utas√≠t√°sok.‚Äù

## Return

A f√ºggv√©nyek n√©ha nem csak csin√°lnak valamit (pl. ki√≠rnak sz√∂veget), hanem vissza is adnak egy eredm√©nyt.
Ehhez haszn√°ljuk a `return` kulcssz√≥t.

```py
def osszead(a, b):
    return a + b

eredmeny = osszead(3, 5)
print(eredmeny)
```

</section>

<section>

# Lok√°lis v√°ltoz√≥k

A robotodnak van egy kis saj√°t fi√≥kja.
Amikor a robot dolgozik, ebbe a fi√≥kba teszi azokat a v√°ltoz√≥kat, amiket csak ≈ë ismer.
Ezeket nevezz√ºk lok√°lis v√°ltoz√≥knak.

üëâ A lok√°lis v√°ltoz√≥ csak abban a f√ºggv√©nyben √©l, ahol l√©trehoztad.
Amint a f√ºggv√©ny lefut, a v√°ltoz√≥ elt≈±nik ‚Äì mintha a robot lez√°rn√° a fi√≥kj√°t.


```py
def szorzas():
    eredmeny = 3 * 5   # lok√°lis v√°ltoz√≥
    print("Az eredm√©ny:", eredmeny)

szorzas()
print(eredmeny)  # ‚ùå hiba!
```

# Glob√°lis vs. Lok√°lis

Glob√°lis v√°ltoz√≥ &rarr; mindenki l√°tja (a teljes programban).

Lok√°lis v√°ltoz√≥ &rarr; csak a f√ºggv√©ny l√°tja, ahol l√©trej√∂tt.


</section>

<section>

# Procedur√°lis/hierarchikus programoz√°s

K√©pzeld el, hogy a programod egy sz√≠ndarab üé≠.

A f√ºggv√©nyek = a sz√≠n√©szek, akik tudnak k√ºl√∂nb√∂z≈ë dolgokat.

A main f√ºggv√©ny = a f≈ëszerepl≈ë, aki elind√≠tja a darabot, √©s megmondja, milyen sorrendben t√∂rt√©njenek a dolgok.

```py
def main():
    print("Hell√≥, √©n vagyok a f≈ëszerepl≈ë!")
    seged()

def seged():
    print("√ân pedig egy mell√©kszerepl≈ë vagyok.")

if __name__ == "__main__":
    main()
```

Mit jelentenek ezek?

if __name__ == "__main__":

Ez egy var√°zsformula ‚ú®, ami azt mondja:

‚ÄûHa k√∂zvetlen√ºl futtatod ezt a f√°jlt, ind√≠tsd el a main()-t!‚Äù

Ha viszont csak import√°lod a f√°jlt m√°shonnan, akkor nem fut el automatikusan a main().

</section>

<section>

# Feladatok

1. Legyen √ñn is Milliomos
2. Hatos lott√≥
3. Telefonk√∂nyv keres√©s

</section>